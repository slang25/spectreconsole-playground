@implements IAsyncDisposable

<div id="@_containerId" class="terminal-container"></div>

<style>
    .terminal-container {
        width: 100%;
        height: 100%;
        padding: 8px;
        box-sizing: border-box;
    }

    .terminal-container .xterm {
        height: 100%;
    }

    .terminal-container .xterm-viewport {
        overflow-y: auto !important;
    }

    /* Hide the native text caret in Firefox for ghostty-web */
    .terminal-container,
    .terminal-container * {
        caret-color: transparent !important;
    }

    /* Hollow block cursor when terminal is unfocused */
    .terminal-container.cursor-inactive .xterm-cursor-block {
        background-color: transparent !important;
        outline: 1px solid #d4d4d4 !important;
        outline-offset: -1px;
    }
</style>

@code {
    private readonly string _containerId = $"terminal-{Guid.NewGuid():N}";
    private bool _isInitialized;

    [Parameter]
    public EventCallback OnCtrlCPressed { get; set; }

    /// <summary>
    /// Initialize the shared terminal IO and start the terminal.
    /// Call this before executing code.
    /// </summary>
    public async Task<Services.SharedTerminalIO> InitializeAsync()
    {
        // Create SharedTerminalIO (this loads the module and registers buffers with JS)
        var terminalIO = await Services.SharedTerminalIO.CreateAsync();

        // Start the terminal in the container
        Services.SharedTerminalIO.StartTerminal(_containerId);

        _isInitialized = true;

        return terminalIO;
    }

    /// <summary>
    /// Get the terminal size.
    /// </summary>
    public Task<(int Cols, int Rows)> GetSize()
    {
        if (_isInitialized)
        {
            var (cols, rows) = Services.SharedTerminalIO.GetTerminalSize();
            return Task.FromResult((cols, rows));
        }
        return Task.FromResult((80, 24));
    }

    /// <summary>
    /// Write text to the terminal.
    /// Uses SharedTerminalIO ring buffer which bypasses JS interop.
    /// </summary>
    public Task Write(string text)
    {
        var io = Services.SharedTerminalIO.Instance;
        if (io != null)
        {
            io.WriteOutput(text);
        }
        return Task.CompletedTask;
    }

    /// <summary>
    /// Write a line to the terminal.
    /// </summary>
    public Task WriteLine(string text = "")
    {
        return Write(text + "\r\n");
    }

    /// <summary>
    /// Clear the terminal.
    /// </summary>
    public Task Clear()
    {
        if (_isInitialized)
        {
            Services.SharedTerminalIO.ClearTerminal();
        }
        return Task.CompletedTask;
    }

    /// <summary>
    /// Focus the terminal.
    /// </summary>
    public Task Focus()
    {
        if (_isInitialized)
        {
            Services.SharedTerminalIO.FocusTerminal();
        }
        return Task.CompletedTask;
    }

    /// <summary>
    /// Stop the terminal polling (call after execution ends).
    /// </summary>
    public Task Stop()
    {
        if (_isInitialized)
        {
            Services.SharedTerminalIO.StopTerminal();
        }
        return Task.CompletedTask;
    }

    public ValueTask DisposeAsync()
    {
        // SharedTerminalIO is a singleton and manages its own lifecycle
        // We just stop polling when this component is disposed
        if (_isInitialized)
        {
            Services.SharedTerminalIO.StopTerminal();
        }
        return ValueTask.CompletedTask;
    }
}
