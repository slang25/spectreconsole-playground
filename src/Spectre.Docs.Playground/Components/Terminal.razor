@implements IAsyncDisposable
@inject IJSRuntime JSRuntime

<div id="@_containerId" class="terminal-container" @onfocusin="OnFocusIn" @onfocusout="OnFocusOut"></div>

<style>
    .terminal-container {
        width: 100%;
        height: 100%;
        padding: 8px;
        box-sizing: border-box;
    }

    .terminal-container .xterm {
        height: 100%;
    }

    .terminal-container .xterm-viewport {
        overflow-y: auto !important;
    }

    /* Hide the native text caret in Firefox for ghostty-web */
    .terminal-container,
    .terminal-container * {
        caret-color: transparent !important;
    }

    /* Hollow block cursor when terminal is unfocused */
    .terminal-container.cursor-inactive .xterm-cursor-block {
        background-color: transparent !important;
        outline: 1px solid #d4d4d4 !important;
        outline-offset: -1px;
    }
</style>

@code {
    private readonly string _containerId = $"terminal-{Guid.NewGuid():N}";
    private string? _terminalId;
    private DotNetObjectReference<Terminal>? _dotNetRef;
    private readonly System.Threading.Channels.Channel<TerminalKeyInfo> _inputChannel =
        System.Threading.Channels.Channel.CreateUnbounded<TerminalKeyInfo>();
    private bool _isInitializing;
    private bool _isInitialized;

    [Parameter]
    public EventCallback OnCtrlCPressed { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_isInitialized && !_isInitializing)
        {
            _isInitializing = true;
            try
            {
                _dotNetRef = DotNetObjectReference.Create(this);
                _terminalId = await JSRuntime.InvokeAsync<string>(
                    "terminalInterop.init",
                    _containerId,
                    _dotNetRef);
                _isInitialized = _terminalId != null;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Terminal initialization failed: {ex.Message}");
            }
            finally
            {
                _isInitializing = false;
            }
        }
    }

    [JSInvokable]
    public void OnTerminalInput(string data)
    {
        // Parse the input data into key info
        foreach (var c in data)
        {
            var keyInfo = ParseKeyFromChar(c);
            _inputChannel.Writer.TryWrite(keyInfo);
        }
    }

    [JSInvokable]
    public void OnTerminalKey(TerminalKeyEvent keyEvent)
    {
        // Handle special keys from xterm
        var keyInfo = ParseKeyEvent(keyEvent);
        if (keyInfo != null)
        {
            _inputChannel.Writer.TryWrite(keyInfo);
        }
    }

    [JSInvokable]
    public async Task OnCtrlC()
    {
        await OnCtrlCPressed.InvokeAsync();
    }

    private TerminalKeyInfo ParseKeyFromChar(char c)
    {
        return c switch
        {
            '\r' or '\n' => new TerminalKeyInfo(ConsoleKey.Enter, '\r', false, false, false),
            '\t' => new TerminalKeyInfo(ConsoleKey.Tab, '\t', false, false, false),
            '\b' or '\x7f' => new TerminalKeyInfo(ConsoleKey.Backspace, '\b', false, false, false),
            '\x1b' => new TerminalKeyInfo(ConsoleKey.Escape, '\x1b', false, false, false),
            _ when c >= 'a' && c <= 'z' => new TerminalKeyInfo((ConsoleKey)(ConsoleKey.A + (c - 'a')), c, false, false, false),
            _ when c >= 'A' && c <= 'Z' => new TerminalKeyInfo((ConsoleKey)(ConsoleKey.A + (c - 'A')), c, true, false, false),
            _ when c >= '0' && c <= '9' => new TerminalKeyInfo((ConsoleKey)(ConsoleKey.D0 + (c - '0')), c, false, false, false),
            ' ' => new TerminalKeyInfo(ConsoleKey.Spacebar, ' ', false, false, false),
            _ => new TerminalKeyInfo(ConsoleKey.NoName, c, false, false, false)
        };
    }

    private TerminalKeyInfo? ParseKeyEvent(TerminalKeyEvent keyEvent)
    {
        var shift = keyEvent.DomEvent.ShiftKey;
        var alt = keyEvent.DomEvent.AltKey;
        var ctrl = keyEvent.DomEvent.CtrlKey;

        // First try to match by DomEvent.Code (standard DOM KeyboardEvent property)
        var result = keyEvent.DomEvent.Code switch
        {
            // Arrow keys for navigation
            "ArrowUp" => new TerminalKeyInfo(ConsoleKey.UpArrow, '\0', shift, alt, ctrl),
            "ArrowDown" => new TerminalKeyInfo(ConsoleKey.DownArrow, '\0', shift, alt, ctrl),
            "ArrowLeft" => new TerminalKeyInfo(ConsoleKey.LeftArrow, '\0', shift, alt, ctrl),
            "ArrowRight" => new TerminalKeyInfo(ConsoleKey.RightArrow, '\0', shift, alt, ctrl),
            // Page navigation
            "Home" => new TerminalKeyInfo(ConsoleKey.Home, '\0', shift, alt, ctrl),
            "End" => new TerminalKeyInfo(ConsoleKey.End, '\0', shift, alt, ctrl),
            "PageUp" => new TerminalKeyInfo(ConsoleKey.PageUp, '\0', shift, alt, ctrl),
            "PageDown" => new TerminalKeyInfo(ConsoleKey.PageDown, '\0', shift, alt, ctrl),
            // Editing keys
            "Delete" => new TerminalKeyInfo(ConsoleKey.Delete, '\0', shift, alt, ctrl),
            "Insert" => new TerminalKeyInfo(ConsoleKey.Insert, '\0', shift, alt, ctrl),
            "Backspace" => new TerminalKeyInfo(ConsoleKey.Backspace, '\b', shift, alt, ctrl),
            // Common action keys
            "Enter" or "NumpadEnter" => new TerminalKeyInfo(ConsoleKey.Enter, '\r', shift, alt, ctrl),
            "Tab" => new TerminalKeyInfo(ConsoleKey.Tab, '\t', shift, alt, ctrl),
            "Escape" => new TerminalKeyInfo(ConsoleKey.Escape, '\x1b', shift, alt, ctrl),
            "Space" => new TerminalKeyInfo(ConsoleKey.Spacebar, ' ', shift, alt, ctrl),
            _ => null
        };

        if (result != null)
            return result;

        // Fall back to parsing escape sequences from the key property
        // This handles terminal emulators like ghostty-web that may not populate domEvent.code
        return keyEvent.Key switch
        {
            // Arrow keys (CSI sequences: ESC [ A/B/C/D)
            "\x1b[A" or "\x1bOA" => new TerminalKeyInfo(ConsoleKey.UpArrow, '\0', shift, alt, ctrl),
            "\x1b[B" or "\x1bOB" => new TerminalKeyInfo(ConsoleKey.DownArrow, '\0', shift, alt, ctrl),
            "\x1b[C" or "\x1bOC" => new TerminalKeyInfo(ConsoleKey.RightArrow, '\0', shift, alt, ctrl),
            "\x1b[D" or "\x1bOD" => new TerminalKeyInfo(ConsoleKey.LeftArrow, '\0', shift, alt, ctrl),
            // Home/End (CSI sequences)
            "\x1b[H" or "\x1bOH" or "\x1b[1~" => new TerminalKeyInfo(ConsoleKey.Home, '\0', shift, alt, ctrl),
            "\x1b[F" or "\x1bOF" or "\x1b[4~" => new TerminalKeyInfo(ConsoleKey.End, '\0', shift, alt, ctrl),
            // Page Up/Down
            "\x1b[5~" => new TerminalKeyInfo(ConsoleKey.PageUp, '\0', shift, alt, ctrl),
            "\x1b[6~" => new TerminalKeyInfo(ConsoleKey.PageDown, '\0', shift, alt, ctrl),
            // Delete/Insert
            "\x1b[3~" => new TerminalKeyInfo(ConsoleKey.Delete, '\0', shift, alt, ctrl),
            "\x1b[2~" => new TerminalKeyInfo(ConsoleKey.Insert, '\0', shift, alt, ctrl),
            // Backspace (can be DEL or BS depending on terminal)
            "\x7f" or "\b" => new TerminalKeyInfo(ConsoleKey.Backspace, '\b', shift, alt, ctrl),
            // Enter
            "\r" or "\n" => new TerminalKeyInfo(ConsoleKey.Enter, '\r', shift, alt, ctrl),
            // Tab
            "\t" => new TerminalKeyInfo(ConsoleKey.Tab, '\t', shift, alt, ctrl),
            // Escape (just the escape character)
            "\x1b" => new TerminalKeyInfo(ConsoleKey.Escape, '\x1b', shift, alt, ctrl),
            _ => null // Regular characters handled by OnTerminalInput
        };
    }

    public async Task Write(string text)
    {
        if (_terminalId != null)
        {
            await JSRuntime.InvokeVoidAsync("terminalInterop.write", _terminalId, text);
        }
    }

    public async Task WriteLine(string text = "")
    {
        if (_terminalId != null)
        {
            await JSRuntime.InvokeVoidAsync("terminalInterop.writeLine", _terminalId, text);
        }
    }

    public async Task Clear()
    {
        if (_terminalId != null)
        {
            await JSRuntime.InvokeVoidAsync("terminalInterop.clear", _terminalId);
        }
        // Clear the input channel
        while (_inputChannel.Reader.TryRead(out _)) { }
    }

    public async Task Focus()
    {
        if (_terminalId != null)
        {
            await JSRuntime.InvokeVoidAsync("terminalInterop.focus", _terminalId);
        }
    }

    private async Task OnFocusIn()
    {
        if (_terminalId != null)
        {
            await JSRuntime.InvokeVoidAsync("terminalInterop.setFocused", _terminalId, true);
        }
    }

    private async Task OnFocusOut()
    {
        if (_terminalId != null)
        {
            await JSRuntime.InvokeVoidAsync("terminalInterop.setFocused", _terminalId, false);
        }
    }

    public async Task<(int Cols, int Rows)> GetSize()
    {
        if (_terminalId != null)
        {
            var size = await JSRuntime.InvokeAsync<TerminalSize>("terminalInterop.getSize", _terminalId);
            return (size.Cols, size.Rows);
        }
        return (80, 24);
    }

    public async ValueTask<TerminalKeyInfo> ReadKeyAsync(CancellationToken cancellationToken = default)
    {
        return await _inputChannel.Reader.ReadAsync(cancellationToken);
    }

    public async ValueTask DisposeAsync()
    {
        if (_terminalId != null)
        {
            await JSRuntime.InvokeVoidAsync("terminalInterop.dispose", _terminalId);
        }
        _dotNetRef?.Dispose();
    }

    public record TerminalKeyInfo(ConsoleKey Key, char KeyChar, bool Shift, bool Alt, bool Control);

    public class TerminalKeyEvent
    {
        public string Key { get; set; } = "";
        public DomEventInfo DomEvent { get; set; } = new();
    }

    public class DomEventInfo
    {
        public string Key { get; set; } = "";
        public string Code { get; set; } = "";
        public bool CtrlKey { get; set; }
        public bool AltKey { get; set; }
        public bool ShiftKey { get; set; }
    }

    public class TerminalSize
    {
        public int Cols { get; set; }
        public int Rows { get; set; }
    }
}
